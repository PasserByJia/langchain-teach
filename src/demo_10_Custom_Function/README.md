# Demo 10: 在 LangChain 中使用自定义函数

这个示例演示了如何在 LangChain 中使用自定义函数，主要涵盖了以下几个方面：

1.  **使用 `RunnableLambda.from` 包装自定义函数**: 明确地将一个自定义函数转换成 `Runnable` 对象。
2.  **在链中自动转换自定义函数**: 在 `RunnableSequence.from` 中直接使用自定义函数，LangChain 会自动将其转换为 `Runnable`。
3.  **在自定义函数中接收和使用 `RunnableConfig`**: 允许在运行时传递回调、标签等配置信息。
4.  **在链中使用生成器函数进行流式处理**: 通过 `yield` 关键字实现流式输出，例如自定义解析器。

## 文件结构

```
.
├── README.md
└── index.ts
```

## 核心概念

### 1. `RunnableLambda`

`RunnableLambda` 是 LangChain 提供的一个工具，用于将任何可调用的函数或对象包装成一个 `Runnable`。这使得自定义的逻辑可以无缝地集成到 LangChain 的链式（Chain）操作中。

- **使用场景**:
  - **数据预处理**: 在将数据传递给语言模型之前，进行格式化、清洗或转换。例如，从一个复杂对象中提取特定字段，或者将用户输入转换为模型可以理解的格式。
  - **动态提示词**: 根据输入动态生成提示词的一部分。例如，根据用户的地理位置，在提示词中插入当地的天气信息。
  - **自定义输出处理**: 对模型的输出进行后处理，例如解析非结构化文本、过滤不相关内容或将其转换为特定的数据结构。

- **示例中的应用**: The `lengthFunction` calculates the length of a string and passes it to the next step in the chain.

  ```typescript
  const lengthFunction = (input: { foo: string }): { length: string } => {
    return {
      length: input.foo.length.toString(),
    };
  };

  const chainWithRunnableLambda = RunnableLambda.from(lengthFunction)
    .pipe(prompt)
    .pipe(model)
    .pipe(new StringOutputParser());
  ```

### 2. 自动转换

当在 `RunnableSequence.from` 中使用自定义函数时，LangChain 会自动将其包装成 `RunnableLambda`，简化了代码。

- **使用场景**:
  - **简化代码**: 对于简单的、一次性的操作，可以直接在链中定义一个匿名函数，而无需单独创建一个 `RunnableLambda`。这使得代码更简洁、易读。
  - **快速原型开发**: 在探索和构建复杂的链时，可以快速地插入一些小的处理步骤，而无需担心繁琐的包装过程。

- **示例中的应用**: An anonymous function is used to take the first 50 characters of the story generated by the model.

  ```typescript
  const chainWithCoercedFunction = RunnableSequence.from([
    storyPrompt,
    storyModel,
    (input) => input.content.slice(0, 50), // 自动转换为 RunnableLambda
  ]);
  ```

### 3. `RunnableConfig`

自定义函数可以接收一个 `RunnableConfig` 参数，用于在运行时传递配置信息，如回调函数、标签等。

- **使用场景**:
  - **调试与追踪**: 通过传递 `callbacks`，可以记录链中每一步的输入和输出，或者在特定事件发生时触发自定义逻辑。这对于调试复杂的链非常有帮助。
  - **可配置的行为**: 可以通过 `configurable` 字段传递参数，动态地改变链的行为。例如，在不同的环境下使用不同的模型或提示词。
  - **元数据与标签**: 使用 `tags` 为链的运行添加元数据，便于后续的分析和过滤。

- **示例中的应用**: The `echo` function receives a `RunnableConfig` object, which is used to pass tags and callbacks to the inner chain.

  ```typescript
  const echo = (text: string, config: RunnableConfig) => {
    // ...
    return chain.invoke({ text }, config);
  };

  await chainWithConfig.invoke("foo", {
    tags: ["my-tag"],
    callbacks: [
      {
        handleLLMEnd: (output) => console.log('LLM Output:', JSON.stringify(output, null, 2)),
      },
    ],
  });
  ```

### 4. 流式处理与生成器

通过使用生成器函数（`async function*`），可以实现流式处理，这对于需要逐步处理输出的场景（如自定义解析器）非常有用。

- **使用场景**:
  - **实时响应**: 在处理需要较长时间生成的文本时，可以逐步地将结果返回给用户，而不是等待整个过程完成。这大大改善了用户体验。
  - **自定义解析器**: 对于流式输出的非结构化数据（如 JSON、XML 或自定义格式），可以编写一个生成器函数来实时解析，并以结构化的形式 `yield` 出来。
  - **处理大型数据集**: 在处理大型数据集时，可以使用生成器来逐块处理数据，避免一次性将所有数据加载到内存中。

- **示例中的应用**: The `splitIntoList` function is a generator that takes a stream of text and yields a list of strings, split by commas.

  ```typescript
  async function* splitIntoList(input: AsyncGenerator<string>) {
    // ...
    yield item.trim();
    // ...
  }

  const streamingParserChain = streamingChain.pipe(splitIntoList);
  ```

## 如何运行

1.  确保你已经安装了所有依赖：

    ```bash
    npm install
    ```

2.  确保你的 `.env` 文件中已经配置了 `OPENAI_API_KEY`。

3.  运行示例：

    ```bash
    npx ts-node src/demo_10_Custom_Function/index.ts
    ```

## 预期输出

运行后，你将看到四个部分的输出，分别对应上面介绍的四个功能点。每个部分都会有清晰的日志信息，展示了链的执行过程和结果。